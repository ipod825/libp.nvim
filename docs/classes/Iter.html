<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>libp</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>libp</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Methods">Methods</a></li>
</ul>


<h2>Classes</h2>
<ul class="nowrap">
  <li><a href="../classes/Class.html">Class</a></li>
  <li><strong>Iter</strong></li>
  <li><a href="../classes/Job.html">Job</a></li>
  <li><a href="../classes/KVIter.html">KVIter</a></li>
  <li><a href="../classes/List.html">List</a></li>
  <li><a href="../classes/OrderedDict.html">OrderedDict</a></li>
  <li><a href="../classes/Set.html">Set</a></li>
  <li><a href="../classes/Stack.html">Stack</a></li>
  <li><a href="../classes/VIter.html">VIter</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/libp.argparse.tokenizer.html">libp.argparse.tokenizer</a></li>
  <li><a href="../modules/libp.datatype.itertools.html">libp.datatype.itertools</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/README.md.html">README</a></li>
</ul>

</div>

<div id="content">

<h1>Class <code>Iter</code></h1>
<p>Module: <strong>libp.datatype.Iter</strong></p>

<p> Iterator interface for <strong>kv iterable</strong>: key/value containers (array and
 table) or generator functions that returns key/value pairs.</p>
<p> The iterator class enables user to create operation chains on <strong>kv iterable</strong>:</p>

<pre>
<span class="global">assert</span>.are.same(
    { <span class="number">4</span>, <span class="number">8</span> },
    VIter({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> }):filter(<span class="keyword">function</span>(v)
        <span class="keyword">return</span> v % <span class="number">2</span> == <span class="number">0</span>
    <span class="keyword">end</span>):map(<span class="keyword">function</span>(v)
        <span class="keyword">return</span> <span class="number">2</span> * v
    <span class="keyword">end</span>):collect()
)
</pre>

<p> It also makes iterating values over container cleaner:
 Instead of writing</p>

<pre>
<span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="global">ipairs</span>({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }) <span class="keyword">do</span>
<span class="keyword">end</span>
</pre>

<p> One could write:</p>

<pre>
<span class="comment">-- itertools.values is equivalent to VIter
</span><span class="keyword">for</span> v <span class="keyword">in</span> itertools.values({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }) <span class="keyword">do</span>
<span class="keyword">end</span>
</pre>

<p> In practice, use the two derived class <a href="../classes/VIter.html#">VIter</a> and <a href="../classes/KVIter.html#">KVIter</a> as <a href="../classes/Iter.html#">Iter</a> itself
 is not for-loop compatible. Both <a href="../classes/VIter.html#">VIter</a> and <a href="../classes/KVIter.html#">KVIter</a> works with <strong>kv
 iterable</strong>. The difference is their return types for <a href="../classes/Iter.html#Iter:next">Iter:next</a> and
 <a href="../classes/Iter.html#Iter:collect">Iter.collect</a>. <a href="../classes/VIter.html#">VIter</a> returns
 the value types of the iterable and <a href="../classes/KVIter.html#">KVIter</a> returns the key/value pairs.</p>

<p> <a href="../classes/Iter.html#">Iter</a> can also be constructed from a generator function whose return values
 should be key/value pairs. <a href="../modules/libp.datatype.itertools.html#range">libp.datatype.itertools.range</a> is a good example for this.</p>

<p> Inherits: <a href="../classes/Class.html#">Class</a></p>


<h2><a href="#Methods">Methods</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#Iter:collect">Iter:collect ()</a></td>
	<td class="summary">Returns a container hosting the results of <a href="../classes/Iter.html#Iter:next">next</a> calls (until it returns
 nil).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:filter">Iter:filter (filter_fn)</a></td>
	<td class="summary">Returns a new iterator that filters the value type with a filter function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:filterkv">Iter:filterkv (filter_fn)</a></td>
	<td class="summary">Returns a new iterator that filters the key/value with a filter function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:init">Iter:init (invariant[, next_fn=nil[, control=nil]])</a></td>
	<td class="summary">Constructor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:map">Iter:map (map_fn)</a></td>
	<td class="summary">Returns a new iterator that transforms the value type with a map function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:mapkv">Iter:mapkv (map_fn)</a></td>
	<td class="summary">Returns a new iterator that transforms the key/value with a map function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:next">Iter:next ()</a></td>
	<td class="summary">Returns the current result and moves the iterator to the next position.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iter:pairs">Iter:pairs ()</a></td>
	<td class="summary">Returns the generic for (next function, invariant, control) tuple.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Methods"></a>Methods</h2>

    <dl class="function">
    <dt>
    <a name = "Iter:collect"></a>
    <strong>Iter:collect ()</strong>
    </dt>
    <dd>
    Returns a container hosting the results of <a href="../classes/Iter.html#Iter:next">next</a> calls (until it returns
 nil).  The return type is decided by the derived iterator class. For e.g.,
 <a href="../classes/VIter.html#">VIter</a> returns an array and <a href="../classes/KVIter.html#">KVIter</a> returns a table.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">array</span> or <a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">assert</span>.are.same({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }, VIter({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }):collect())</pre>
    </ul>

</dd>
    <dt>
    <a name = "Iter:filter"></a>
    <strong>Iter:filter (filter_fn)</strong>
    </dt>
    <dd>
    Returns a new iterator that filters the value type with a filter function.
 For example, if the original iterator returns <code>(k1, v1), (k2, v2)</code> ...
 The mapped iterator will return <code>(k2, v2)</code> ..., assuming that
 <code>filter_fn(v1)=false</code> and <code>filter_fn(v1)=true</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filter_fn</span>
            <span class="types"><span class="type">function(any)->boolean</span></span>
         The filter function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../classes/Iter.html#">Iter</a></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">assert</span>.are.same(
    { <span class="number">1</span>, <span class="number">3</span> },
    VIter({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }):filter(<span class="keyword">function</span>(v)
        <span class="keyword">return</span> v % <span class="number">2</span> ~= <span class="number">0</span>
    <span class="keyword">end</span>):collect()
)</pre>
    </ul>

</dd>
    <dt>
    <a name = "Iter:filterkv"></a>
    <strong>Iter:filterkv (filter_fn)</strong>
    </dt>
    <dd>
    Returns a new iterator that filters the key/value with a filter function.
 For example, if the original iterator returns <code>(k1, v1), (k2, v2)</code> ...
 The mapped iterator will return <code>(k2, v2)</code> ..., assuming that
 <code>filter_fn(k1, v1)=false</code> and <code>filter_fn(k1, v1)=true</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">filter_fn</span>
            <span class="types"><span class="type">function(any,any)->boolean</span></span>
         The filter function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../classes/Iter.html#">Iter</a></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">assert</span>.are.same(
    { a = <span class="number">1</span>, c = <span class="number">3</span> },
    KVIter({ a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span> }):filterkv(<span class="keyword">function</span>(k, v)
        <span class="keyword">return</span> k == <span class="string">"a"</span> <span class="keyword">or</span> v == <span class="number">3</span>
    <span class="keyword">end</span>):collect()
)</pre>
    </ul>

</dd>
    <dt>
    <a name = "Iter:init"></a>
    <strong>Iter:init (invariant[, next_fn=nil[, control=nil]])</strong>
    </dt>
    <dd>
    Constructor.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">invariant</span>
            <span class="types"><span class="type">array</span>, <a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a> or <span class="type">nil</span></span>
         The underlying key/value container. If nil,
 <code>next_fn</code> must be non nil.
        </li>
        <li><span class="parameter">next_fn</span>
            <span class="types"><span class="type">function(invariant,control)->next_control,value</span></span>

<p> The
 underlying generator function. If not provided, lua's built-in next function
 is used to iterate over <code>invariant</code>. The signature of <code>next_fn</code> is:</p>

<ul>
    <li>invariant: The container to iterate over. Can be nil in generator function case.</li>
    <li>control: The current iterator position. nil represents the pre-begin position.</li>
    <li>next_control: The next iterator position. nil represents the post-end position.</li>
    <li>value: The value at the current position (control).</li>
</ul>


         (<em>default</em> nil)
        </li>
        <li><span class="parameter">control</span>
            <span class="types"><span class="type">any</span></span>
         The beginning iterator position.
         (<em>default</em> nil)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>




    </ol>




</dd>
    <dt>
    <a name = "Iter:map"></a>
    <strong>Iter:map (map_fn)</strong>
    </dt>
    <dd>
    Returns a new iterator that transforms the value type with a map function.
 For example, if the original iterator returns <code>(k1, v1), (k2, v2)</code> ...
 The mapped iterator will return <code>(k1, map_fn(v1)), (k2, map_fn(v2))</code> ...


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">map_fn</span>
            <span class="types"><span class="type">function(any)->any</span></span>
         The map function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../classes/Iter.html#">Iter</a></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="global">assert</span>.are.same(
    { <span class="number">2</span>, <span class="number">4</span> },
    VIter({ <span class="number">1</span>, <span class="number">2</span> }):map(<span class="keyword">function</span>(v)
        <span class="keyword">return</span> <span class="number">2</span> * v
    <span class="keyword">end</span>):collect()
)</pre>
    </ul>

</dd>
    <dt>
    <a name = "Iter:mapkv"></a>
    <strong>Iter:mapkv (map_fn)</strong>
    </dt>
    <dd>
    Returns a new iterator that transforms the key/value with a map function.
 For example, if the original iterator returns <code>(k1, v1), (k2, v2)</code> ...
 The mapped iterator will return <code>map_fn(k1, v1), map_fn(k2, v2)</code> ...


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">map_fn</span>
            <span class="types"><span class="type">function(any,any)->any,any</span></span>
         The map function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="../classes/Iter.html#">Iter</a></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">-- { "a", "b" } is equivalent to { [1] = "a", [2] = "b" },
</span><span class="global">assert</span>.are.same(
    { a = <span class="number">1</span>, b = <span class="number">2</span> },
    KVIter({ <span class="string">"a"</span>, <span class="string">"b"</span> }):mapkv(<span class="keyword">function</span>(k, v)
        <span class="keyword">return</span> v, k
    <span class="keyword">end</span>):collect()
)</pre>
    </ul>

</dd>
    <dt>
    <a name = "Iter:next"></a>
    <strong>Iter:next ()</strong>
    </dt>
    <dd>
    Returns the current result and moves the iterator to the next position.  It
 is not implemented in <a href="../classes/Iter.html#">Iter</a>, the derived classes must implement this
 function and decide the return types. For e.g., <a href="../classes/VIter.html#VIter:next">VIter:next</a> returns a
 single value and <a href="../classes/KVIter.html#KVIter:next">KVIter:next</a> returns two values. This function is
 triggered by the <code>__call</code> operator and is thus for-loop compatible. However,
 users can also calls it explicitly to get just the next result.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">any</span></span>



    </ol>



    <h3>Usage:</h3>
    <ul>
        <li><pre class="example"><span class="keyword">for</span> i, v <span class="keyword">in</span> KIter({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }) <span class="keyword">do</span>
    <span class="global">assert</span>(i == v)
<span class="keyword">end</span></pre></li>
        <li><pre class="example"><span class="keyword">local</span> iter = VIter({ <span class="number">1</span>, <span class="number">2</span> })
<span class="global">assert</span>(iter:<span class="global">next</span>() == <span class="number">1</span>)
<span class="global">assert</span>(iter:<span class="global">next</span>() == <span class="number">2</span>)
<span class="global">assert</span>(iter:<span class="global">next</span>() == <span class="keyword">nil</span>)</pre></li>
    </ul>

</dd>
    <dt>
    <a name = "Iter:pairs"></a>
    <strong>Iter:pairs ()</strong>
    </dt>
    <dd>
    Returns the generic for (next function, invariant, control) tuple.
 This function is probably only of interest to derived class of <a href="../classes/Iter.html#">Iter</a>.







</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-08-12 11:10:37 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
